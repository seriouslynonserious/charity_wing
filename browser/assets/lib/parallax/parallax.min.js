(function($, window, document) {

    function Parallax(element, options) {
        var self = this;

        if (typeof options === 'object') {
            delete options.refresh;
            delete options.render;
            $.extend(this, options);
        }

        this.$element = $(element);

        if (!this.imageSrc && this.$element.is("img")) {
            this.imageSrc = this.$element.attr("src");
        }

        var position = (this.position + "").toLowerCase().match(/\S+/g) || [];

        if (position.length < 1) position.push("center");
        if (position.length === 1) position.push(position[0]);

        if ("top" !== position[0] && "bottom" !== position[0] && "left" !== position[1] && "right" !== position[1]) {
            position = [position[1], position[0]];
        }

        if (this.positionX !== undefined) position[0] = this.positionX.toLowerCase();
        if (this.positionY !== undefined) position[1] = this.positionY.toLowerCase();

        self.positionX = position[0];
        self.positionY = position[1];

        if ("left" !== this.positionX && "right" !== this.positionX) {
            if (isNaN(parseInt(this.positionX))) {
                this.positionX = "center";
            } else {
                this.positionX = parseInt(this.positionX);
            }
        }

        if ("top" !== this.positionY && "bottom" !== this.positionY) {
            if (isNaN(parseInt(this.positionY))) {
                this.positionY = "center";
            } else {
                this.positionY = parseInt(this.positionY);
            }
        }

        this.position = this.positionX + (isNaN(this.positionX) ? "" : "px") + " " + this.positionY + (isNaN(this.positionY) ? "" : "px");

        if (navigator.userAgent.match(/(iPod|iPhone|iPad)/)) {
            if (this.imageSrc && this.iosFix && !this.$element.is("img")) {
                this.$element.css({
                    backgroundImage: "url(" + this.imageSrc + ")",
                    backgroundSize: "cover",
                    backgroundPosition: this.position
                });
            }
            return this;
        }

        if (navigator.userAgent.match(/(Android)/)) {
            if (this.imageSrc && this.androidFix && !this.$element.is("img")) {
                this.$element.css({
                    backgroundImage: "url(" + this.imageSrc + ")",
                    backgroundSize: "cover",
                    backgroundPosition: this.position
                });
            }
            return this;
        }

        this.$mirror = $("<div />").prependTo(this.mirrorContainer);
        var $existingSlider = this.$element.find(">.parallax-slider"),
            alreadyHasSlider = false;

        if ($existingSlider.length === 0) {
            this.$slider = $("<img />").prependTo(this.$mirror);
        } else {
            this.$slider = $existingSlider.prependTo(this.$mirror);
            alreadyHasSlider = true;
        }

        this.$mirror.addClass("parallax-mirror").css({
            visibility: "hidden",
            zIndex: this.zIndex,
            position: "fixed",
            top: 0,
            left: 0,
            overflow: "hidden"
        });

        this.$slider.addClass("parallax-slider").one("load", function() {
            if (!self.naturalHeight || !self.naturalWidth) {
                self.naturalHeight = this.naturalHeight || this.height || 1;
                self.naturalWidth = this.naturalWidth || this.width || 1;
            }

            if (!Parallax.isSetup) {
                Parallax.setup();
            }

            Parallax.sliders.push(self);
            Parallax.isFresh = false;
            Parallax.requestRender();
        });

        if (!alreadyHasSlider) {
            this.$slider[0].src = this.imageSrc;
        }

        if ((this.naturalHeight && this.naturalWidth) || this.$slider[0].complete || $existingSlider.length > 0) {
            this.$slider.trigger("load");
        }
    }

    (function() {
        var lastTime = 0,
            vendors = ["ms", "moz", "webkit", "o"];

        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        }

        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }

        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
    })();

    $.extend(Parallax.prototype, {
        speed: 0.2,
        bleed: 0,
        zIndex: -100,
        iosFix: true,
        androidFix: true,
        position: "center",
        overScrollFix: false,
        mirrorContainer: "body",
        
        refresh: function() {
            this.boxWidth = this.$element.outerWidth();
            this.boxHeight = this.$element.outerHeight() + 2 * this.bleed;
            this.boxOffsetTop = this.$element.offset().top - this.bleed;
            this.boxOffsetLeft = this.$element.offset().left;
            this.boxOffsetBottom = this.boxOffsetTop + this.boxHeight;

            var scrollTop = Parallax.scrollTop,
                winHeight = Parallax.winHeight,
                docHeight = Parallax.docHeight;

            var topViewport = Math.min(this.boxOffsetTop, docHeight - winHeight),
                bottomViewport = Math.max(this.boxOffsetTop + this.boxHeight - winHeight, 0);

            var sliderHeight = this.boxHeight + (topViewport - bottomViewport) * (1 - this.speed) | 0,
                sliderTop = (this.boxOffsetTop - topViewport) * (1 - this.speed) | 0;

            if (sliderHeight * this.aspectRatio >= this.boxWidth) {
                this.imageWidth = sliderHeight * this.aspectRatio | 0;
                this.imageHeight = sliderHeight;
                this.offsetBaseTop = sliderTop;
                var extraWidth = this.imageWidth - this.boxWidth;

                if ("left" === this.positionX) {
                    this.offsetLeft = 0;
                } else if ("right" === this.positionX) {
                    this.offsetLeft = -extraWidth;
                } else if (isNaN(this.positionX)) {
                    this.offsetLeft = -extraWidth / 2 | 0;
                } else {
                    this.offsetLeft = Math.max(this.positionX, -extraWidth);
                }
            } else {
                this.imageWidth = this.boxWidth;
                this.imageHeight = this.boxWidth / this.aspectRatio | 0;
                this.offsetLeft = 0;

                var extraHeight = this.imageHeight - sliderHeight;

                if ("top" === this.positionY) {
                    this.offsetBaseTop = sliderTop;
                } else if ("bottom" === this.positionY) {
                    this.offsetBaseTop = sliderTop - extraHeight;
                } else if (isNaN(this.positionY)) {
                    this.offsetBaseTop = sliderTop - extraHeight / 2 | 0;
                } else {
                    this.offsetBaseTop = sliderTop + Math.max(this.positionY, -extraHeight);
                }
            }
        },

        render: function() {
            var scrollTop = Parallax.scrollTop,
                scrollLeft = Parallax.scrollLeft,
                overScroll = this.overScrollFix ? Parallax.overScroll : 0,
                viewportBottom = scrollTop + Parallax.winHeight;

            if (this.boxOffsetBottom > scrollTop && this.boxOffsetTop <= viewportBottom) {
                this.visibility = "visible";
                this.mirrorTop = this.boxOffsetTop - scrollTop;
                this.mirrorLeft = this.boxOffsetLeft - scrollLeft;
                this.offsetTop = this.offsetBaseTop - this.mirrorTop * (1 - this.speed);
            } else {
                this.visibility = "hidden";
            }

            this.$mirror.css({
                transform: "translate3d(" + this.mirrorLeft + "px, " + (this.mirrorTop - overScroll) + "px, 0px)",
                visibility: this.visibility,
                height: this.boxHeight,
                width: this.boxWidth
            });

            this.$slider.css({
                transform: "translate3d(" + this.offsetLeft + "px, " + this.offsetTop + "px, 0px)",
                position: "absolute",
                height: this.imageHeight,
                width: this.imageWidth,
                maxWidth: "none"
            });
        }
    });

    $.extend(Parallax, {
        scrollTop: 0,
        scrollLeft: 0,
        winHeight: 0,
        winWidth: 0,
        docHeight: 1 << 30,
        docWidth: 1 << 30,
        sliders: [],
        isReady: false,
        isFresh: false,
        isBusy: false,

        setup: function() {
            if (this.isReady) return;

            var $doc = $(document),
                $win = $(window);

            $win.on("resize.px.parallax load.px.parallax", function() {
                Parallax.winHeight = $win.height();
                Parallax.winWidth = $win.width();
                Parallax.docHeight = $doc.height();
                Parallax.docWidth = $doc.width();
                Parallax.isFresh = false;
                Parallax.requestRender();
            }).on("scroll.px.parallax", function() {
                var scrollTopMax = Parallax.docHeight - Parallax.winHeight;
                var scrollLeftMax = Parallax.docWidth - Parallax.winWidth;

                Parallax.scrollTop = Math.max(0, Math.min(scrollTopMax, $win.scrollTop()));
                Parallax.scrollLeft = Math.max(0, Math.min(scrollLeftMax, $win.scrollLeft()));
                Parallax.overScroll = Math.max($win.scrollTop() - scrollTopMax, Math.min($win.scrollTop(), 0));
                Parallax.requestRender();
            });

            this.isReady = true;
        },

        configure: function(options) {
            if (typeof options === 'object') {
                delete options.refresh;
                delete options.render;
                $.extend(this.prototype, options);
            }
        },

        refresh: function() {
            $.each(this.sliders, function() {
                this.refresh();
            });
            this.isFresh = true;
        },

        render: function() {
            this.isBusy = true;
            $.each(this.sliders, function() {
                this.render();
            });
            this.isBusy = false;
        },

        requestRender: function() {
            var self = this;
            if (!self.isBusy) {
                window.requestAnimationFrame(self.render.bind(self));
            }
        }
    });

    var $parallax = $.fn.parallax;

    $.fn.parallax = function(options) {
        return this.each(function() {
            var $this = $(this),
                parallax = $this.data("px.parallax");

            if (!parallax) {
                options = $.extend({}, $this.data(), typeof options === 'object' && options);
                $this.data("px.parallax", (parallax = new Parallax(this, options)));
            }

            if (typeof options === 'string') {
                parallax[options]();
            }
        });
    };

    $.fn.parallax.Constructor = Parallax;

    $.fn.parallax.noConflict = function() {
        $.fn.parallax = $parallax;
        return this;
    };

    $(function() {
        $('[data-parallax="scroll"]').parallax();
    });

})(jQuery, window, document);
